<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">

<!--
Internal component that display the hour or minute selector

version : __2.0.0__

This is a complete rewrite of the version 1, that doesn't work on firefox. it's now based on pure HTML and doesn't use SVG.

Example:

      <zdkelt-clock minutes id="minuteClock" value="{{minutes}}"
            on-update="_minutesChange" on-change="_setMinutes"></zdkelt-clock2>

![](hero-clock.png)

The component has been tested on :

 - chrome 47 ( desktop & tablet )
 - firefox 44
 - ipad2  

@group zdk Elements
@demo demo/zdkelt-clock.html
-->
<dom-module id="zdkelt-clock">
  <template>
    <style is="custom-style">
      #clock {
        position: relative;
        width: 200px;
        height: 200px;
        background: var(--divider-color, #dbdbdb);
        border-radius: 50%;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        cursor: pointer;
      }

      .tick {
        position: absolute;
        font-family: Roboto, verdana;
        font-size: 14px;
        text-align: center;
        width: 24px;
        height: 24px;
        line-height: 24px;
        margin-top: -12px;
        margin-left: -12px;
      }

      #selector {
        position: absolute;
        top: 100px;
        left: 100px;
        transform: rotate(180deg);
        transform-origin: top left;
      }

      .central-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--default-primary-color, #3f51b5);
        margin-top: -3px;
        margin-left: -3px;
      }

      .line {
        height: 82px;
        width: 2px;
        background: var(--default-primary-color, #3f51b5);
        margin-left: -1px;
      }

      .sline {
        height: 52px !important;
      }

      .large-dot {
        position: relative;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background: var(--default-primary-color, #3f51b5);
        margin-top: -15px;
        margin-left: -15px;
      }

      .dot {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--default-primary-color, #3f51b5);
        margin-top: -5px;
        margin-left: -5px;
        top: 15px;
        left: 15px;
      }

      .ldot-minutes {
        background: var(--light-primary-color, #c5cae9);
      }

      .select {
        color: var(--primary-background-color, #ffffff);
      }

    </style>
    <div id="clock" on-down="_startSelect" on-track="_dragSelect" on-up="_finishSelect">
      <div id="selector">
        <div class="central-dot"></div>
        <div class="line"></div>
        <div class="large-dot">
          <div class="dot"></div>
        </div>
      </div>
      <div id="ticks"></div>
    </div>
  </template>
  <script>
    class ZdkEltClock extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() {
        return 'zdkelt-clock'
      }
      static get properties() {
        return {
          /**
           * The value selected
           */
          value: {
            type: Number,
            value: 0,
            reflectToAttribute: true,
            notify: true,
            observer: '_valueChanged',
          },
          /**
           * Boolean flag indicates to draw minutes clock
           */
          minutes: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            notify: true,
            observer: '_viewChanged',
          },
          /**
           * Boolean flag indicates to draw our clock with 12 hours
           */
          hour12: {
            type: Boolean,
            value: false,
          },
          /**
           * the meridiem value : 'AM'|'PM'
           *
           * __Nota :__ not yet implemented
           */
          meridiem: {
            type: String,
            reflectToAttribute: true,
            notify: true,
          },
          /**
           * The radius of the clock
           */
          _radius: {
            type: Number,
          },
          /**
           * internal flag indicating when the mouse is down
           */
          _down: {
            type: Boolean,
            value: false,
          },
        }
      }

      connectedCallBack() {
        super.connectedCallBack()
        this._radius = this.$.clock.offsetWidth / 2 - 15
        this._viewChanged()
      }

      /**
       * change the view function of the `minutes` property
       */
      _viewChanged() {
        this.$.ticks.innerHTML = ''
        if (!this.$.clock.offsetWidth) {
          return
        }
        this._radius = this.$.clock.offsetWidth / 2 - 15
        if (this.minutes) {
          this._minutedraw()
        } else {
          this._hour12draw()
          this._hour24draw()
        }
      }

      /**
       * Draw the the hour clock ( 0 to 11 )
       */
      _hour12draw() {
        var ticks = this.$.ticks
        var angleOffset = -360 / 12 * (Math.PI / 180)
        var angle = Math.PI / 2
        var radius = this._radius
        var radiusTot = this.$.clock.offsetWidth / 2

        Array.from(Array(12).keys())
          .map(Number.call, Number)
          .map((tickLabel, indx) => {
            var tick = document.createElement('div')
            tick.classList.add('tick')
            tick.innerHTML = tickLabel
            tick.setAttribute('value', tickLabel)
            if (indx === 0) {
              tick.classList.toggle('select')
            }
            ticks.appendChild(tick)

            var x = radius * Math.cos(angle + angleOffset * indx) + radiusTot
            var y = -radius * Math.sin(angle + angleOffset * indx) + radiusTot
            var transform = 'translate(' + x + 'px,' + y + 'px)'
            tick.style.transform = transform
          })
      }

      /**
       * Draw the the hour clock ( 12 to 23 )
       */
      _hour24draw() {
        var angleOffset = -360 / 12 * (Math.PI / 180)
        var angle = Math.PI / 2
        var ticks = this.$.ticks
        var radius = this._radius
        var radiusTot = this.$.clock.offsetWidth / 2

        Array.from(Array(12).keys())
          .map(Number.call, Number)
          .map((tickLabel, indx) => {
            var tick = document.createElement('div')
            tick.classList.add('tick')
            tick.innerHTML = tickLabel + 12
            tick.setAttribute('value', tickLabel + 12)
            ticks.appendChild(tick)
            var x = (radius - 30) * Math.cos(angle + angleOffset * indx) + radiusTot
            var y = -(radius - 30) * Math.sin(angle + angleOffset * indx) + radiusTot
            var transform = 'translate(' + x + 'px,' + y + 'px)'
            tick.style.transform = transform
          })
      }

      /**
       * Draw the minutes clock
       */
      _minutedraw() {
        var angleOffset = -360 / 60 * (Math.PI / 180)
        var angle = Math.PI / 2
        var ticks = this.$.ticks
        var radius = this._radius
        var radiusTot = this.$.clock.offsetWidth / 2

        Array.from(Array(60).keys())
          .map(Number.call, Number)
          .map((tickLabel, indx) => {
            var tick = document.createElement('div')
            tick.classList.add('tick')
            if (indx % 5 === 0) {
              tick.innerHTML = indx
            }
            if (indx === 0) {
              tick.classList.toggle('select')
            }
            tick.setAttribute('value', indx)
            ticks.appendChild(tick)
            var x = radius * Math.cos(angle + angleOffset * indx) + radiusTot
            var y = -radius * Math.sin(angle + angleOffset * indx) + radiusTot
            var transform = 'translate(' + x + 'px,' + y + 'px)'
            tick.style.transform = transform
          })
        const shadowRoot = this.shadowRoot
        const line = shadowRoot.querySelector('.line')
        if (line.classList.contains('sline')) {
          line.classList.remove('sline')
        }
      }

      /**
       * an `update` event is emitted when the value change by dragging the mouse
       * @event update
       */
      _valueChanged() {
        var ticks = Array.from(this.$.ticks.querySelectorAll('.tick'))
        if (!ticks.length) {
          return
        }
        var selected = this.$.ticks.querySelector('.tick.select')
        if (selected) {
          selected.classList.toggle('select')
        }
        if (this.value < 0 || this.value > ticks.length - 1) {
          this.value = 0
        }
        this._selectorPos()
        this.dispatchEvent(new CustomEvent('update', {detail: this.value}))
      }

      /**
       * Draw the selector
       */
      _selectorPos() {
        if (isNaN(this.value)) {
          return
        }
        var line
        var ticks = Array.from(this.$.ticks.querySelectorAll('.tick'))
        ticks[this.value].classList.toggle('select')
        var angleOffset = this.minutes ? 6 : 30
        var theta = (this.value + (this.minutes ? 30 : 6)) * angleOffset
        var transform = 'rotate(' + theta + 'deg)'
        this.$.selector.style.transform = transform
        line = this.$.clock.querySelector('.line')
        var classList = this.$.clock.querySelector('.large-dot').classList
        if (this.minutes) {
          line.classList.remove('sline')
          if (this.value % 5 === 0) {
            classList.remove('ldot-minutes')
          } else {
            if (!classList.contains('ldot-minutes')) {
              classList.add('ldot-minutes')
            }
          }
        } else {
          classList.remove('ldot-minutes')
          line = this.$.clock.querySelector('.line')
          if (this.value >= 12) {
            if (!line.classList.contains('sline')) {
              line.classList.add('sline')
            }
          } else {
            if (line.classList.contains('sline')) {
              line.classList.remove('sline')
            }
          }
        }
      }

      _startSelect(evt) {
        this._down = true
        this._dragSelect(evt)
      }

      /**
       * return polar coordinate
       *
       * the angle is offset by 90° to obtain 0 at the the "0" position
       * @return {*} the polar coordiante { a: angle, r: radius }
       */
      _getEltCoordinate(x, y) {
        var rect = this.$.clock.getBoundingClientRect()
        var coord = {
          x: x - rect.left - this.$.clock.offsetWidth / 2,
          y: y - rect.top - this.$.clock.offsetHeight / 2,
        }
        var radius = Math.sqrt(coord.x * coord.x + coord.y * coord.y)
        var theta = Math.atan(coord.y / coord.x)
        theta = (Math.PI / 2) + theta + (coord.x < 0 ? Math.PI : 0)

        return {
          a: theta * 180 / Math.PI,
          r: radius,
        }
      }

      _dragSelect(evt) {
        if (!this._down) {
          return
        }
        var angleOffset = this.minutes ? 6 : 30
        var coord = this._getEltCoordinate(evt.detail.x, evt.detail.y)
        // get the nearest point
        var indx = Math.round(coord.a / angleOffset)
        if (!this.minutes && indx === 12) {
          indx = 0
        }
        this.value = indx + (this.minutes ? 0 : (coord.r > this._radius - 20) ? 0 : 12)
      }

      /**
       * an `change` event is emitted when the mouse is released
       *
       * @event change
       */
      _finishSelect() {
        this._down = false
        this.dispatchEvent(new CustomEvent('change', {detail: this.value, bubble: true}))
      }
    }

    window.customElements.define(ZdkEltClock.is, ZdkEltClock)
  </script>
</dom-module>
